import Base#mbRT

// :::::::::::::::::
// :: Extra Utils ::
// :::::::::::::::::

T V3
| v3(x: Number, y: Number, z: Number) 

map_v3(fn: Number -> Number, v: V3) : V3
  case v
  | v3 => v3(fn(v.x), fn(v.y), fn(v.z))

// Vector accessors
get_x(v: V3); case v | v3 => v.x
get_y(v: V3); case v | v3 => v.y
get_z(v: V3); case v | v3 => v.z

mut_x(fn: Number -> Number, v: V3) : V3
  case v
  | v3 => v3(fn(v.x), v.y, v.z)

mut_y(fn: Number -> Number, v: V3) : V3
  case v
  | v3 => v3(v.x, fn(v.y), v.z)

mut_z(fn: Number -> Number, v: V3) : V3
  case v
  | v3 => v3(v.x, v.y, fn(v.z))

add_v3(a: V3, b: V3) : V3
  case a
  | v3 =>
    case b
    | v3 => v3(
      a.x .+. b.x, 
      a.y .+. b.y, 
      a.z .+. b.z)

map_list(A; B; fn: A -> B, xs: List(A)) : List(B)
  case xs
  | nil  => []
  | cons => cons(_ fn(xs.head), map_list(__ fn, xs.tail))

generate_list.go(A;
  idx : Number,
  len : Number,
  fn  : Number -> A
) : List(A)
  if idx .==. len then
    []
  else
    cons(_ fn(idx), generate_list.go(A; idx .+. 1, len, fn))

generate_list(A; len: Number, fn: Number -> A) : List(A)
  generate_list.go(A; 0, len, fn)

// ::::::::::::::::
// :: Game Logic ::
// ::::::::::::::::

// :: GAME OBJECT ::

ObjectId : Type
  Number

T GameObject
| game_object(
  id: ObjectId,
  hp: Number,
  pos: V3,
  dir: V3,
  vel: V3,
  size: V3)

// Object accessors >> will be generated by macros <<
get_object_id(obj: GameObject); case obj | game_object => obj.id
get_object_hp(obj: GameObject); case obj | game_object => obj.hp
get_object_pos(obj: GameObject); case obj | game_object => obj.pos
get_object_dir(obj: GameObject); case obj | game_object => obj.dir
get_object_vel(obj: GameObject); case obj | game_object => obj.vel
get_object_size(obj: GameObject); case obj | game_object => obj.size

// Changes the object's direction
mut_object_dir(fn: V3 -> V3, obj: GameObject) : GameObject
  case obj
  | game_object =>
    game_object(
      obj.id,
      obj.hp,
      obj.pos,
      fn(obj.dir),
      obj.vel,
      obj.size)

// :: GAME MAP ::

GameMap : Type
  List(GameObject)

// Gets the position of an object on the game map
get_object_from_map(id: ObjectId, gm: GameMap)
: Maybe(GameObject)
  case gm
  | nil  => none(_)
  | cons =>
    case gm.head
    | game_object => 
      if gm.head.id .==. id then
        some(_ gm.head)
      else
        get_object_from_map(id, gm.tail)

// :: GAME ::

T Game
| game(map : GameMap)

get_game_map(game: Game) : GameMap
  case game
  | game => game.map

get_object_position(id: ObjectId, gs: Game) : V3
  case get_object(id, gs) as got
  | none => v3(0,0,0)
  | some => get_object_pos(got.value)

// Gets the position of an object on the game state
get_object(id: ObjectId, gs: Game) : Maybe(GameObject)
  case gs
  | game => get_object_from_map(id, gs.map)

// :: TESTS ::

SRPX : Number; 0
STANCI : Number; 1
NEELIX : Number; 2

srpx : GameObject
  let id = 0
  let hp = 70
  let pos = v3(0, 0, 0)
  let dir = v3(0, 0, 0)
  let vel = v3(0, 0, 0)
  let size = v3(12,12,18)
  game_object(id, hp, pos, dir, vel, size)

stanci : GameObject
  let id = 1
  let hp = 90
  let pos = v3(64, 0, 0)
  let dir = v3(0, 0, 0)
  let vel = v3(0, 0, 0)
  let size = v3(12,12,12)
  game_object(id, hp, pos, dir, vel, size)

neelix : GameObject
  let id = 2
  let hp = 700
  let pos = v3(-64, 0, 0)
  let dir = v3(0, 0, 0)
  let vel = v3(0, 0, 0)
  let size = v3(6,6,6)
  game_object(id, hp, pos, dir, vel, size)

belanna : GameObject
  let id = 3
  let hp = 80
  let pos = v3(0, 64, 0)
  let dir = v3(0, 0, 0)
  let vel = v3(0, 0, 0)
  let size = v3(6,6,6)
  game_object(id, hp, pos, dir, vel, size)

demo_game : Game
  let map = [srpx, stanci, neelix, belanna]
  game(map)

//tick_game_object(go: GameObject) : GameObject
  //case go
  //| game_object =>
    //case go.pos
    //| v3 =>
      //let new_id   = go.id
      //let new_hp   = go.hp
      //let new_pos  = v3(go.pos.x, go.pos.y, go.pos.z)
      //let new_size = go.size
      //game_object(new_id, new_hp, new_pos, new_size)

//tick_game_map(gm: GameMap) : GameMap
  //case gm
  //| nil  => []
  //| cons => cons(_
    //tick_game_object(gm.head),
    //tick_game_map(gm.tail))

//tick_game(gs: Game) : Game
  //case gs
  //| game => game(tick_game_map(gs.map))

// ::::::::::::::::
// :: Game Input ::
// ::::::::::::::::

T GameEvent
| game_move(id: ObjectId, dir: V3)

// Modifies every object in the game
map_game_objects(
  fn : GameObject -> GameObject,
  gm : Game
) : Game
  game(map_list(__ fn, get_game_map(gm)))

// Apply an event to the game state
input_game(event: GameEvent, gm: Game) : Game
  case event
  | game_move =>
    let fn = (object) =>
      case object
      | game_object =>
        if event.id .==. object.id then
          mut_object_dir((old_dir) => event.dir, object)
        else
          object
    map_game_objects(fn, gm)

tick_game(gm: Game) : Game
  let fn = (obj) =>
    case obj
    | game_object =>
      let new_id   = obj.id
      let new_hp   = obj.hp
      let new_pos  = add_v3(obj.pos, obj.dir)
      let new_dir  = obj.dir
      let new_vel  = obj.vel
      let new_size = obj.size
      game_object(
        new_id, new_hp, new_pos,
        new_dir, new_vel, new_size)
  map_game_objects(fn, gm)
    


  //id: ObjectId,
  //hp: Maybe(Number),
  //pos: V3,
  //vel: V3,
  //size: V3)
          
          

    //map_game_object(fn, gm)
    
    
    
    



