import Base#9y4x
import TaelinArena.Geometry
import TaelinArena.Game
import TaelinArena.Models
import TaelinArena.Heroes

// Creates a new reseted hero given its HeroId
new_hero(hid: HeroId) : Thing
  case get_hero_by_hid(hid) as hero |hero
  case hero.stat | stat
  let id  = 0
  let hid = hid
  let act = 0
  let tik = 0
  let chp = hero.stat.mhp
  let pos = v3(0,0,0)
  let spd = 0
  let dir = v3(0,-1,0)
  let vel = v3(0,0,0)
  let box = cbox(hero.stat.rad)
  thing(id,hid,act,tik,chp,pos,spd,dir,vel,box)

// Apply a player input to the game state
exec_command(cmd: Command, gm: Game) : Game
  case cmd |command
  let fn = (thi: Thing) =>
    case cmd.inp as inp
    with thi : Thing
    | sdir =>
      case thi |thing
      case get_hero_by_hid(thi.hid) as her |hero
      case her.stat as sta |stat
      let mov = len_v3(inp.dir) === 0
      let dfn = (d: V3    ) => if mov then d else inp.dir
      let sfn = (s: Number) => if mov then 0 else sta.spd
      let thi = thi <= thing(dir = dfn(dir))
      let thi = thi <= thing(spd = sfn(spd))
      thi
    | key0 => thi
    | key1 => thi
    | key2 => thi
    | key3 => thi
    | key4 => thi
    | key5 => thi
    | cmsg => thi
  let fn = (thi: Thing) =>
    case thi |thing
    case get_hero_by_hid(thi.hid) as hro |hero
    hro.inpt(fn(thi), cmd.inp)
  with_thing(cmd.pid, fn, gm)

interact_with(this:Thing, that:Thing): Thing
  case this |thing
  case that |thing
  case this.box
  | cbox => 
    case that.box
    | cbox =>  
      let dst = dist_v3(this.pos, that.pos)
      let rad = this.box.rad + that.box.rad
      if (dst > that.box.rad) && (dst < rad) then
        let out_dir = norm_v3(sub_v3(this.pos, that.pos))
        let out_vec = scale_v3(rad - dst, out_dir)
        let new_pos = add_v3(this.pos, out_vec)
        this <= thing(pos = new_pos)
      else
        this
    | pbox =>
      this
  | pbox =>
    this

// Game's main loop
exec_turn(gm: Game) : Game
  let tick = (stage: List(Thing), thi: Thing) =>
    case thi |thing
    case get_hero_by_hid(thi.hid) as hro | hero
    let nps = add_v3(thi.pos, scale_v3(thi.spd, thi.dir))
    let ntk = thi.tik + 1
    let itr = (that, this) => interact_with(this, that)
    let thi = thi <= thing(pos = nps, tik = ntk)
    let thi = hro.tick(thi)
    let thi = fold(Thing; _ thi, itr, stage)
    thi
  gm <= game(stage = map(Thing; _ tick(stage), stage))

// TODO: very hard coded, comment, improve, etc.
draw_thing(thi: Thing) : Draw 
  case thi |thing
  case get_hero_by_hid(thi.hid) as hro | hero
  hro.draw(thi)

srpx : Thing
  new_hero(MIKEGATOR_HERO) <= thing(pid=0, pos=v3(0,0,0))

stanci : Thing
  new_hero(MIKEGATOR_HERO) <= thing(pid=1, pos=v3(-64,0,0))

neelix : Thing
  new_hero(MIKEGATOR_HERO) <= thing(pid=2, pos=v3(64,0,0))

belanna : Thing
  new_hero(MIKEGATOR_HERO) <= thing(pid=3, pos=v3(0,64,0))

new_game : Game
  game([srpx, stanci, neelix, belanna])
