import Base#0OIj
import Geometry

// :: COLLISION ::

T Hitbox
| circbox(rad: Number)
| polybox(pts: List(V3))

// :: GAME OBJECT ::

ObjectId : Type
  Number

ModelId : Type
  Number

T Anim
| anim(
  id  : Number,
  tik : Number)

T GameObject
| game_object(
  id  : ObjectId,
  hp  : Number,
  pos : V3,
  spd : Number,
  dir : V3,
  vel : V3,
  box : Hitbox,
  ani : Anim)


// :: GAME MAP ::

GameMap : Type
  List(GameObject)

// Gets the position of an object on the game map
get_object_from_map(id: ObjectId, gm: GameMap)
: Maybe(GameObject)
  case gm
  | nil  => none(_)
  | cons =>
    case gm.head |game_object
    if gm.head.id === id then
      some(_ gm.head)
    else
      get_object_from_map(id, gm.tail)

// :: GAME ::

T Game
| game(map : GameMap)

get_game_map(game: Game) : GameMap
  case game |game
  game.map

// Gets an object by its id
get_object_by_id(id: ObjectId, gs: Game) : Maybe(GameObject)
  case gs |game
  get_object_from_map(id, gs.map)

// Gets the position of an object by its id
get_position_by_id(id: ObjectId, gs: Game) : V3
  case get_object_by_id(id, gs) as got
  | none => v3(0,0,0)
  | some => case got.value |game_object
    got.value.pos

// :: TESTS ::

SRPX : Number; 0
STANCI : Number; 1
NEELIX : Number; 2
BELANNA : Number; 3

srpx : GameObject
  let id = 0
  let hp = 70
  let pos = v3(0, 0, 0)
  let spd = 0
  let dir = v3(0, -1, 0)
  let vel = v3(0, 0, 0)
  let box = circbox(10)
  let ani = anim(0, 0)
  game_object(id, hp, pos, spd, dir, vel, box, ani)

stanci : GameObject
  let id = 1
  let hp = 90
  let pos = v3(64, 0, 0)
  let spd = 0
  let dir = v3(0, -1, 0)
  let vel = v3(0, 0, 0)
  let box = circbox(8)
  let ani = anim(0, 0)
  game_object(id, hp, pos, spd, dir, vel, box, ani)

neelix : GameObject
  let id = 2
  let hp = 700
  let pos = v3(-64, 0, 0)
  let spd = 0
  let dir = v3(0, -1, 0)
  let vel = v3(0, 0, 0)
  let box = v3(6,6,6)
  let box = circbox(8)
  let ani = anim(0, 0)
  game_object(id, hp, pos, spd, dir, vel, box, ani)

belanna : GameObject
  let id = 3
  let hp = 80
  let pos = v3(0, 64, 0)
  let spd = 0
  let dir = v3(0, -1, 0)
  let vel = v3(0, 0, 0)
  let box = circbox(14)
  let ani = anim(0, 0)
  game_object(id, hp, pos, spd, dir, vel, box, ani)

new_game : Game
  let map = [srpx, stanci, neelix, belanna]
  game(map)

// GAME INPUT

T GameAction
| game_sdir(id: ObjectId, dir: V3) // stick direction
| game_key0(id: ObjectId, pos: V3) // left down
| game_key1(id: ObjectId, pos: V3) // middle down
| game_key2(id: ObjectId, pos: V3) // right down
| game_key3(id: ObjectId, pos: V3) // space down
| game_key4(id: ObjectId, pos: V3) // extra down
| game_key5(id: ObjectId, pos: V3) // shift down
| game_text(id: ObjectId, txt: String) // chat message

// Modifies every object in the game
map_game_objects(
  fn : GameObject -> GameObject,
  gm : Game
) : Game
  game(map(__ fn, get_game_map(gm)))

// Modifies the object with given id
// TODO: Optimize
modify_object_by_id(
  id: ObjectId,
  fn: GameObject -> GameObject,
  gm: Game
) : Game
  let fn2 = (obj) =>
    case obj |game_object
    if obj.id === id then
      fn(obj)
    else
      obj
  game(map(GameObject; _ fn2, get_game_map(gm)))

// Apply an action to the game state
exec_game_action(action: GameAction, gm: Game) : Game
  case action
  | game_sdir =>
    let fn = (obj) =>
      case obj |game_object
      // Change its direction if analog isn't centered
      let dir_fn =
        if len_v3(action.dir) === 0 then
          (old_dir: V3) => old_dir
        else
          (old_dir: V3) => action.dir
      // Set its speed if analog isn't centered
      let spd_fn =
        if len_v3(action.dir) === 0 then
          (old_spd: Number) => 0
        else
          (old_spd: Number) =>
            if obj.id === 3 then
              3
            else
              6
      // Modify the object using the logic above
      let obj = obj <= game_object(dir = dir_fn(dir))
      let obj = obj <= game_object(spd = spd_fn(spd))
      obj
    modify_object_by_id(action.id, fn, gm)
  | game_key0 =>
    let fn = (obj) =>
      obj <= game_object(pos = action.pos)
    modify_object_by_id(action.id, fn, gm)
  | game_key1 => gm
  | game_key2 => gm
  | game_key3 =>
    let fn = (obj) =>
      obj <= game_object(ani = anim(1,0))
    modify_object_by_id(action.id, fn, gm)
  | game_key4 => gm
  | game_key5 => gm
  | game_text => gm

interact_with(this:GameObject, that:GameObject): GameObject
  case this |game_object
  case that |game_object
  case this.box
  | circbox => 
    case that.box
    | circbox =>  
      let dst = dist_v3(this.pos, that.pos)
      let rad = this.box.rad + that.box.rad
      if (dst > that.box.rad) && (dst < rad) then
        let out_dir = norm_v3(sub_v3(this.pos, that.pos))
        let out_vec = scale_v3(rad - dst, out_dir)
        let new_pos = add_v3(this.pos, out_vec)
        this <= game_object(pos = new_pos)
      else
        this
    | polybox =>
      this
  | polybox =>
    this

// Game's main loop
exec_game_turn(gm: Game) : Game
  case gm |game
  let tick = (obj) =>
    case obj |game_object
    let new_id  = obj.id
    let new_hp  = obj.hp
    let new_spd = obj.spd
    let new_dir = obj.dir
    let new_vel = obj.vel
    let new_box = obj.box
    let new_ani =
      case obj.ani
      | anim =>
        let id  = obj.ani.id
        let tik = obj.ani.tik
        let res =
          let a = (id === 1) && (tik === 15)
          let b = (id === 3) && (tik === 18)
          a || b
        let new_id = if res then 0 else id
        let new_tik = if res then 0 else tik + 1
        anim(new_id, new_tik)
    let new_pos = add_v3(obj.pos, scale_v3(obj.spd, obj.dir))
    let trg_pos = v3(0,64,0)
    let new_obj = game_object(
      new_id, new_hp, new_pos, new_spd,
      new_dir, new_vel, new_box, new_ani)
    let int_fun = (that, this) => interact_with(this, that)
    fold(GameObject; _ new_obj, int_fun, gm.map)
  game(map(GameObject; _ tick, gm.map))

T RenderInfo
| render_info(
  mid: Number,
  pos: V3,
  dir: V3)

// TODO: very hard coded, comment, improve, etc.
get_render_info(obj: GameObject) : RenderInfo 
  case obj |game_object
    let mid =
      case obj.ani |anim
      if obj.id === 0 then
        // idle/walk
        if obj.ani.id === 0 then
          if (obj.spd < 0.1) then
            MIN_IDLE_0 + ((obj.ani.tik \ 3) >>> 0) % 3
          else
            MIN_RUN_0 + ((obj.ani.tik \ 3) >>> 0) % 5
        // attack
        else
          MIN_ATTACKA_0 + ((obj.ani.tik \ 3) >>> 0) % 6
      else if obj.id === 3 then
        // idle/walk
        if obj.ani.id === 0 then
          if (obj.spd < 0.1) then
            ZOIN_IDLE_0 + ((obj.ani.tik \ 3) >>> 0) % 5
          else
            ZOIN_WALK_0 + ((obj.ani.tik \ 3) >>> 0) % 6
        // attack
        else
          ZOIN_ATTACKA_0 + ((obj.ani.tik \ 3) >>> 0) % 7
      else if obj.id === 2 then
        MIKEGATOR_SPINTAIL_0 + ((obj.ani.tik \ 3) >>> 0) % 8
      else
        KENKO_ULTK_0 + ((obj.ani.tik \ 3) >>> 0) % 26
    let pos = obj.pos 
    let dir = obj.dir
    render_info(mid, pos, dir)

SIMPLAO_IDLE1 0
SIMPLAO_IDLE2 1
SIMPLAO_IDLE3 2
SIMPLAO_IDLE4 3
SIMPLAO_ATK1 4
SIMPLAO_ATK2 5
SIMPLAO_ATK3 6
SIMPLAO_ATK4 7
SIMPLAO_MOVE1 8
SIMPLAO_MOVE2 9
SIMPLAO_MOVE3 10
SIMPLAO_MOVE4 11
SIMPLAO_PODER1 12
SIMPLAO_PODER2 13
SIMPLAO_PODER3 14
SIMPLAO_PODER4 15
SIMPLAO_PODER5 16
SIMPLAO_PODER6 17
SIMPLAO_PODER7 18
MIN_IDLE_0 19
MIN_IDLE_1 20
MIN_IDLE_2 21
MIN_RUN_0 22
MIN_RUN_1 23
MIN_RUN_2 24
MIN_RUN_3 25
MIN_RUN_4 26
MIN_ATTACKA_0 27
MIN_ATTACKA_1 28
MIN_ATTACKA_2 29
MIN_ATTACKA_3 30
MIN_ATTACKA_4 31
MIN_ATTACKA_5 32
ZOIN_IDLE_0 33
ZOIN_IDLE_1 34
ZOIN_IDLE_2 35
ZOIN_IDLE_3 36
ZOIN_IDLE_4 37
ZOIN_ATTACKA_0 38
ZOIN_ATTACKA_1 39
ZOIN_ATTACKA_2 40
ZOIN_ATTACKA_3 41
ZOIN_ATTACKA_4 42
ZOIN_ATTACKA_5 43
ZOIN_ATTACKA_6 44
ZOIN_WALK_0 45
ZOIN_WALK_1 46
ZOIN_WALK_2 47
ZOIN_WALK_3 48
ZOIN_WALK_4 49
ZOIN_WALK_5 50
ZOIN_WALK_6 51
MIKEGATOR_WALK_0 52
MIKEGATOR_WALK_1 53
MIKEGATOR_WALK_2 54
MIKEGATOR_WALK_3 55
MIKEGATOR_WALK_4 56
MIKEGATOR_WALK_5 57
MIKEGATOR_WALK_6 58
MIKEGATOR_WALK_7 59
MIKEGATOR_SPINTAIL_0 60
MIKEGATOR_SPINTAIL_1 61
MIKEGATOR_SPINTAIL_2 62
MIKEGATOR_SPINTAIL_3 63
MIKEGATOR_SPINTAIL_4 64
MIKEGATOR_SPINTAIL_5 65
MIKEGATOR_SPINTAIL_6 66
MIKEGATOR_SPINTAIL_7 67
KENKO_ULTK_0 68
KENKO_ULTK_1 69
KENKO_ULTK_2 70
KENKO_ULTK_3 71
KENKO_ULTK_4 72
KENKO_ULTK_5 73
KENKO_ULTK_6 74
KENKO_ULTK_7 75
KENKO_ULTK_8 76
KENKO_ULTK_9 77
KENKO_ULTK_10 78
KENKO_ULTK_11 79
KENKO_ULTK_12 80
KENKO_ULTK_13 81
KENKO_ULTK_14 82
KENKO_ULTK_15 83
KENKO_ULTK_16 84
KENKO_ULTK_17 85
KENKO_ULTK_18 86
KENKO_ULTK_19 87
KENKO_ULTK_20 88
KENKO_ULTK_21 89
KENKO_ULTK_22 90
KENKO_ULTK_23 91
KENKO_ULTK_24 92
KENKO_ULTK_25 93
