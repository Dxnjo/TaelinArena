import Base#9y4x
import Geometry

// :: COLLISION ::

T Hitbox
| circbox(rad: Number)
| polybox(pts: List(V3))

// :: GAME OBJECT ::

ThingId : Type
  Number

ModelId : Type
  Number

T Action
| action(
  id  : Number,
  tik : Number)

T Thing
| thing(
  id  : ThingId,
  hp  : Number,
  pos : V3,
  spd : Number,
  dir : V3,
  vel : V3,
  box : Hitbox,
  act : Action)

// :: GAME ::

T Game
| game(stage : List(Thing))

// Gets a thing from game by its id
get_thing_by_id(id: ThingId, gm: Game) : Maybe(Thing)
  case gm | game
  let cond = (t) => case t |thing number_equal(t.id, id)
  find(Thing; cond, gm.stage)

// Gets the position of an object by its id
get_position_by_id(id: ThingId, gs: Game) : V3
  case get_thing_by_id(id, gs) as found
  |none v3(0,0,0)
  |some case found.value |thing found.value.pos

enum
| SRPX
| STANCI
| NEELIX
| BELANNA

srpx : Thing
  let id = 0
  let hp = 70
  let pos = v3(0, 0, 0)
  let spd = 0
  let dir = v3(0, -1, 0)
  let vel = v3(0, 0, 0)
  let box = circbox(10)
  let act = action(0, 0)
  thing(id, hp, pos, spd, dir, vel, box, act)

stanci : Thing
  let id = 1
  let hp = 90
  let pos = v3(64, 0, 0)
  let spd = 0
  let dir = v3(0, -1, 0)
  let vel = v3(0, 0, 0)
  let box = circbox(8)
  let act = action(0, 0)
  thing(id, hp, pos, spd, dir, vel, box, act)

neelix : Thing
  let id = 2
  let hp = 700
  let pos = v3(-64, 0, 0)
  let spd = 0
  let dir = v3(0, -1, 0)
  let vel = v3(0, 0, 0)
  let box = v3(6,6,6)
  let box = circbox(8)
  let act = action(0, 0)
  thing(id, hp, pos, spd, dir, vel, box, act)

belanna : Thing
  let id = 3
  let hp = 80
  let pos = v3(0, 64, 0)
  let spd = 0
  let dir = v3(0, -1, 0)
  let vel = v3(0, 0, 0)
  let box = circbox(14)
  let act = action(0, 0)
  thing(id, hp, pos, spd, dir, vel, box, act)

new_game : Game
  let stage = [srpx, stanci, neelix, belanna]
  game(stage)

// GAME INPUT

T Input
| game_sdir(id: ThingId, dir: V3) // stick direction
| game_key0(id: ThingId, pos: V3) // left down
| game_key1(id: ThingId, pos: V3) // middle down
| game_key2(id: ThingId, pos: V3) // right down
| game_key3(id: ThingId, pos: V3) // space down
| game_key4(id: ThingId, pos: V3) // extra down
| game_key5(id: ThingId, pos: V3) // shift down
| game_text(id: ThingId, txt: String) // chat message

// Modifies every thing in the game
map_stage(fn: Thing -> Thing, gm: Game) : Game
  gm <= game(stage = map(__ fn, stage))

// Modifies the object with given id
// TODO: Optimize
with_thing(tid: ThingId, fn: Thing -> Thing, gm: Game): Game
  let effect = (thi) =>
    case thi |thing
    case number_equal(thi.id, tid) as e
    with thi : Thing
    | true  => fn(thi)
    | false => thi
  map_stage(effect, gm)

// Apply an input to the game state
exec_input(input: Input, gm: Game) : Game
  case input
  | game_sdir =>
    let fn = (thi) =>
      case thi |thing
      // Change its direction if analog isn't centered
      let dir_fn =
        if len_v3(input.dir) === 0 then
          (old_dir: V3) => old_dir
        else
          (old_dir: V3) => input.dir
      // Set its speed if analog isn't centered
      let spd_fn =
        if len_v3(input.dir) === 0 then
          (old_spd: Number) => 0
        else
          (old_spd: Number) =>
            if thi.id === 3 then
              3
            else
              6
      // Modify the thing using the logic above
      let thi = thi <= thing(dir = dir_fn(dir))
      let thi = thi <= thing(spd = spd_fn(spd))
      thi
    with_thing(input.id, fn, gm)
  | game_key0 =>
    let fn = (thi) =>
      thi <= thing(pos = input.pos)
    with_thing(input.id, fn, gm)
  | game_key1 => gm
  | game_key2 => gm
  | game_key3 =>
    let fn = (thi) =>
      thi <= thing(act = action(1,0))
    with_thing(input.id, fn, gm)
  | game_key4 => gm
  | game_key5 => gm
  | game_text => gm

interact_with(this:Thing, that:Thing): Thing
  case this |thing
  case that |thing
  case this.box
  | circbox => 
    case that.box
    | circbox =>  
      let dst = dist_v3(this.pos, that.pos)
      let rad = this.box.rad + that.box.rad
      if (dst > that.box.rad) && (dst < rad) then
        let out_dir = norm_v3(sub_v3(this.pos, that.pos))
        let out_vec = scale_v3(rad - dst, out_dir)
        let new_pos = add_v3(this.pos, out_vec)
        this <= thing(pos = new_pos)
      else
        this
    | polybox =>
      this
  | polybox =>
    this

// Game's main loop
exec_game_turn(gm: Game) : Game
  case gm |game
  let tick = (obj) =>
    case obj |thing
    let new_id  = obj.id
    let new_hp  = obj.hp
    let new_spd = obj.spd
    let new_dir = obj.dir
    let new_vel = obj.vel
    let new_box = obj.box
    let new_act =
      case obj.act
      | action =>
        let id  = obj.act.id
        let fra = obj.act.tik
        let res =
          let a = (id === 1) && (fra === 15)
          let b = (id === 3) && (fra === 18)
          a || b
        let new_id = if res then 0 else id
        let new_fra = if res then 0 else fra + 1
        action(new_id, new_fra)
    let new_pos = add_v3(obj.pos, scale_v3(obj.spd, obj.dir))
    let trg_pos = v3(0,64,0)
    let new_obj = thing(
      new_id, new_hp, new_pos, new_spd,
      new_dir, new_vel, new_box, new_act)
    let int_fun = (that, this) => interact_with(this, that)
    fold(Thing; _ new_obj, int_fun, gm.stage)
  game(map(Thing; _ tick, gm.stage))

T RenderInfo
| render_info(mid: Number, pos: V3, dir: V3)

// TODO: very hard coded, comment, improve, etc.
get_render_info(obj: Thing) : RenderInfo 
  case obj |thing
    let mid =
      case obj.act |action
      if obj.id === 0 then
        // idle/walk
        if obj.act.id === 0 then
          if (obj.spd < 0.1) then
            MIN_IDLE_0 + ((obj.act.tik \ 3) >>> 0) % 3
          else
            MIN_RUN_0 + ((obj.act.tik \ 3) >>> 0) % 5
        // attack
        else
          MIN_ATTACKA_0 + ((obj.act.tik \ 3) >>> 0) % 6
      else if obj.id === 3 then
        // idle/walk
        if obj.act.id === 0 then
          if (obj.spd < 0.1) then
            ZOIN_IDLE_0 + ((obj.act.tik \ 3) >>> 0) % 5
          else
            ZOIN_WALK_0 + ((obj.act.tik \ 3) >>> 0) % 6
        // attack
        else
          ZOIN_ATTACKA_0 + ((obj.act.tik \ 3) >>> 0) % 7
      else if obj.id === 2 then
        MIKEGATOR_SPINTAIL_0 + ((obj.act.tik \ 3) >>> 0) % 8
      else
        KENKO_ULTK_0 + ((obj.act.tik \ 3) >>> 0) % 26
    let pos = obj.pos 
    let dir = obj.dir
    render_info(mid, pos, dir)

enum
| SIMPLAO_IDLE_1
| SIMPLAO_IDLE_2
| SIMPLAO_IDLE_3
| SIMPLAO_IDLE_4
| SIMPLAO_ATK_1
| SIMPLAO_ATK_2
| SIMPLAO_ATK_3
| SIMPLAO_ATK_4
| SIMPLAO_MOVE_1
| SIMPLAO_MOVE_2
| SIMPLAO_MOVE_3
| SIMPLAO_MOVE_4
| SIMPLAO_PODER_1
| SIMPLAO_PODER_2
| SIMPLAO_PODER_3
| SIMPLAO_PODER_4
| SIMPLAO_PODER_5
| SIMPLAO_PODER_6
| SIMPLAO_PODER_7
| MIN_IDLE_0
| MIN_IDLE_1
| MIN_IDLE_2
| MIN_RUN_0
| MIN_RUN_1
| MIN_RUN_2
| MIN_RUN_3
| MIN_RUN_4
| MIN_ATTACKA_0
| MIN_ATTACKA_1
| MIN_ATTACKA_2
| MIN_ATTACKA_3
| MIN_ATTACKA_4
| MIN_ATTACKA_5
| ZOIN_IDLE_0
| ZOIN_IDLE_1
| ZOIN_IDLE_2
| ZOIN_IDLE_3
| ZOIN_IDLE_4
| ZOIN_ATTACKA_0
| ZOIN_ATTACKA_1
| ZOIN_ATTACKA_2
| ZOIN_ATTACKA_3
| ZOIN_ATTACKA_4
| ZOIN_ATTACKA_5
| ZOIN_ATTACKA_6
| ZOIN_WALK_0
| ZOIN_WALK_1
| ZOIN_WALK_2
| ZOIN_WALK_3
| ZOIN_WALK_4
| ZOIN_WALK_5
| ZOIN_WALK_6
| MIKEGATOR_WALK_0
| MIKEGATOR_WALK_1
| MIKEGATOR_WALK_2
| MIKEGATOR_WALK_3
| MIKEGATOR_WALK_4
| MIKEGATOR_WALK_5
| MIKEGATOR_WALK_6
| MIKEGATOR_WALK_7
| MIKEGATOR_SPINTAIL_0
| MIKEGATOR_SPINTAIL_1
| MIKEGATOR_SPINTAIL_2
| MIKEGATOR_SPINTAIL_3
| MIKEGATOR_SPINTAIL_4
| MIKEGATOR_SPINTAIL_5
| MIKEGATOR_SPINTAIL_6
| MIKEGATOR_SPINTAIL_7
| KENKO_ULTK_0
| KENKO_ULTK_1
| KENKO_ULTK_2
| KENKO_ULTK_3
| KENKO_ULTK_4
| KENKO_ULTK_5
| KENKO_ULTK_6
| KENKO_ULTK_7
| KENKO_ULTK_8
| KENKO_ULTK_9
| KENKO_ULTK_10
| KENKO_ULTK_11
| KENKO_ULTK_12
| KENKO_ULTK_13
| KENKO_ULTK_14
| KENKO_ULTK_15
| KENKO_ULTK_16
| KENKO_ULTK_17
| KENKO_ULTK_18
| KENKO_ULTK_19
| KENKO_ULTK_20
| KENKO_ULTK_21
| KENKO_ULTK_22
| KENKO_ULTK_23
| KENKO_ULTK_24
| KENKO_ULTK_25
